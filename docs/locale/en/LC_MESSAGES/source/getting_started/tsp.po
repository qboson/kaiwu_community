# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022 Beijing QBoson Quantum Technology Co., Ltd
# This file is distributed under the same license as the Kaiwu Community
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Kaiwu Community 1.0.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-09 15:08+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../source/getting_started/tsp.rst:2
msgid "新手教程-QUBO建模-旅行商问题"
msgstr "Beginner's Guide - QUBO Modeling - Traveling Salesman Problem"

#: ../../source/getting_started/tsp.rst:5
msgid "什么是旅行商问题"
msgstr "What is the Traveling Salesman Problem"

#: ../../source/getting_started/tsp.rst:7
msgid ""
"旅行商问题(TravelingSalesmanProblem，TSP)是一个经典的组合优化问题。经典的TSP可以描述为：一个商品推销员要去若干个城市推销商品，"
" 该推销员从一个城市出发，需要经过所有城市后，回到出发地。应如何选择行进路线，以使总的行程最短。"
msgstr ""
"The Traveling Salesman Problem (TSP) is a classic combinatorial optimization problem. The classic TSP can be described as follows: a traveling salesman needs to visit several cities to sell goods. The salesman starts from one city, needs to visit all cities, and then returns to the starting point. How to choose the travel route to minimize the total travel distance."

#: ../../source/getting_started/tsp.rst:10
msgid ""
"从图论的角度来看，该问题实质是在一个带权完全无向图中，找一个权值最小的Hamilton回路。由于该问题的可行解是所有顶点的全排列，随着顶点数的增加，"
" 会产生组合爆炸，它是一个NP完全问题。由于其在交通运输、电路板线路设计以及物流配送等领域内有着广泛的应用，国内外学者对其进行了大量的研究。 "
"早期的研究者使用精确算法求解该问题，常用的方法包括:分支定界法、线性规划法、动态规划法等。但是，随着问题规模的增大，精确算法将变得无能为力，因此，"
" 在后来的研究中，国内外学者重点使用近似算法或启发式算法，主要有遗传算法、模拟退火法、蚁群算法、禁忌搜索算法、贪婪算法和神经网络等。如今， "
"量子计算的出现为该问题的求解提供了全新的方式。"
msgstr ""
"From the perspective of graph theory, this problem is essentially to find a Hamiltonian cycle with the minimum weight in a weighted complete undirected graph. Since the feasible solutions of this problem are all permutations of the vertices, as the number of vertices increases, a combinatorial explosion occurs, making it an NP-complete problem. Due to its wide applications in transportation, circuit board design, and logistics distribution, scholars at home and abroad have conducted extensive research on it. Early researchers used exact algorithms to solve this problem, with common methods including branch and bound, linear programming, and dynamic programming. However, as the problem scale increases, exact algorithms become ineffective. Therefore, in later research, scholars at home and abroad focused on using approximate algorithms or heuristic algorithms, mainly including genetic algorithms, simulated annealing, ant colony algorithms, tabu search, greedy algorithms, and neural networks. Today, the emergence of quantum computing provides a new way to solve this problem."

#: ../../source/getting_started/tsp.rst:19
msgid "旅行商问题分析"
msgstr "Analysis of the Traveling Salesman Problem"

#: ../../source/getting_started/tsp.rst:22
msgid "问题本质"
msgstr "Problem Essence"

#: ../../source/getting_started/tsp.rst:24
msgid "旅行商问题有一点像“最短路径问题”，然后我们就会自然地想到用Dikstra算法去求得“从某一个城市出发，到其他所有剩余城市的最短路径”，再或者如果是个真实地图，我们可以用启发式的“A星算法”快速搜索出“从某-个城市到另一个指定城市间的最短路径\"。但仔细想，这个问题并非单纯这么简单，它还要求去寻找“从某个城市开始，分别经过其它城市一次且仅一次，最后再回到这个出发城市的最短巡回路径”。"
msgstr "The Traveling Salesman Problem is somewhat like the \"shortest path problem\", and we naturally think of using Dijkstra's algorithm to find \"the shortest path from one city to all other remaining cities\", or if it's a real map, we can use the heuristic \"A* algorithm\" to quickly search for \"the shortest path from one city to another specified city\". But upon careful consideration, this problem is not simply that easy. It also requires finding \"the shortest tour path that starts from a city, passes through all other cities exactly once, and finally returns to the starting city\"."

#: ../../source/getting_started/tsp.rst:27
msgid "深入分析"
msgstr "In-depth Analysis"

#: ../../source/getting_started/tsp.rst:29
msgid ""
"旅行商问题要从图G的所有周游路线中求取最小成本的周游路线，而从初始点出发的周游路线一共有(n-1)!条，即等于除初始结点外的n-1个结点的排列数，因此旅行商问题是一个排列问题。排列问题比子集合的选择问题通常要难于求解得多，这是因为n个物体有n!种排列，只有"
" 个子集合(n!>O()）。通过枚举(n-1)!条周游路线，从中找出一条具有最小成本的周游路线的算法，其计算时间显然为O(n!)。"
msgstr ""
"The Traveling Salesman Problem requires finding the minimum cost tour from all tours of graph G. There are (n-1)! tours starting from the initial point, which is equal to the number of permutations of the n-1 nodes except the initial node. Therefore, the Traveling Salesman Problem is a permutation problem. Permutation problems are usually much more difficult to solve than subset selection problems, because there are n! permutations of n objects, while there are only subsets (n! > O()). The computational time of an algorithm that enumerates (n-1)! tours and finds the one with the minimum cost is obviously O(n!)."

#: ../../source/getting_started/tsp.rst:31
msgid "所以该怎么求解呢，我们很容易想到一种类似于穷举的思路：现在假设我们要拜访11个城市，从城市1出发，最后回到城市1。显然，从城市1出来后，我们随即可以选择剩余的10个城市之一进行拜访(这里所有城市都是连通的，总是可达的，而不连通的情况属于个人特殊业务的装饰处理，不是本案例考虑范畴)，那么很显然这里就有10种选择，以此类推，下一次就有9种选择.总的可选路线数就是：10!。也就是说需要用for循环迭代10!次，才能找出所有的路线，进而筛选出最短的那条路线。如果只拜访10个城市的话(需要迭代3628800次)或许还好，那要拜访100个城市(需要迭代9.3326215443944*10^157)简直就是经典计算机的噩梦！更多个城市的话，计算的时间开销可想而知！"
msgstr "So how to solve it? We can easily think of an exhaustive approach: suppose we want to visit 11 cities, starting from city 1 and finally returning to city 1. Obviously, after leaving city 1, we can immediately choose one of the remaining 10 cities to visit (here all cities are connected and always reachable, and disconnected cases are special business decoration processing, not within the scope of this case). So there are obviously 10 choices here, and so on, with 9 choices next time. The total number of optional routes is: 10! That is, we need to iterate 10! times with a for loop to find all routes, and then select the shortest one. If we only visit 10 cities (needing 3,628,800 iterations), it might be manageable, but visiting 100 cities (needing 9.3326215443944*10^157 iterations) is simply a nightmare for classical computers! For more cities, the computational time cost is unimaginable!"

#: ../../source/getting_started/tsp.rst:33
msgid "更一般地，如果要拜访n+1个城市，总的可选路线数就是n!，进而时间复杂度就是O(n!)，从这里我们同理也可以看出，这个算法的时间复杂度是非多项式的，它的开销大是显而易见的。所以问题的关键不在于寻找两两城市间的最短路径，而在于去寻找一那条最短的巡回路径，换句话说，就是寻找一组拜访城市的先后次序序列。"
msgstr "More generally, if we want to visit n+1 cities, the total number of optional routes is n!, and the time complexity is O(n!). From this, we can also see that the time complexity of this algorithm is non-polynomial, and its high cost is obvious. Therefore, the key to the problem is not to find the shortest path between every pair of cities, but to find the shortest tour path, in other words, to find a sequence of visiting cities in order."

#: ../../source/getting_started/tsp.rst:37
msgid "旅行商求解方案"
msgstr "Traveling Salesman Problem Solving Schemes"

#: ../../source/getting_started/tsp.rst:39
msgid "传统的旅行商求解方案主要有:"
msgstr "Traditional Traveling Salesman Problem solving schemes mainly include:"

#: ../../source/getting_started/tsp.rst:41
msgid "TSP旅行商问题-蛮力法(深度遍历优先算法DFS)"
msgstr "TSP Traveling Salesman Problem - Brute Force Method (Depth-First Search Algorithm DFS)"

#: ../../source/getting_started/tsp.rst:42
msgid "TSP_旅行商问题-动态规划"
msgstr "TSP Traveling Salesman Problem - Dynamic Programming"

#: ../../source/getting_started/tsp.rst:43
msgid "TSP旅行商问题-模拟退火算法"
msgstr "TSP Traveling Salesman Problem - Simulated Annealing Algorithm"

#: ../../source/getting_started/tsp.rst:44
msgid "TSP 旅行商问题-遗传算法"
msgstr "TSP Traveling Salesman Problem - Genetic Algorithm"

#: ../../source/getting_started/tsp.rst:45
msgid "TSP 旅行商问题-粒子群算法"
msgstr "TSP Traveling Salesman Problem - Particle Swarm Optimization"

#: ../../source/getting_started/tsp.rst:46
msgid "TSP 旅行商问题-神经网络"
msgstr "TSP Traveling Salesman Problem - Neural Network"

#: ../../source/getting_started/tsp.rst:48
msgid "旅行商问题是个NP完全问题，穷举算法的效率又不高，那我们该如何通过一个多项式时间复杂度的算法快速求出这个先后次序呢？目前比较主流的方法是采用一些随机的、启发式的搜索算法，比如遗传算法、蚁群算法、模拟退货算法、粒子群算法等。但这些算法都有一个缺点，就是不一定能求出最优解，只能收敛于(近似逼近)最优解，得到一个次优解，因为他们本质都是随机算法，大多都会以类似“一定概率接受或舍去\"的思路去筛选解。各算法的实现思路都有不同，但也或多或少有互相借鉴的地方，有的与随机因子有关、有的与初始状态有关、有的与随机函数有关、有的与选择策略有关。"
msgstr "The Traveling Salesman Problem is an NP-complete problem, and the efficiency of exhaustive algorithms is not high. So how can we quickly find this order through an algorithm with polynomial time complexity? Currently, the more mainstream methods are to use some random, heuristic search algorithms, such as genetic algorithms, ant colony algorithms, simulated annealing algorithms, particle swarm optimization, etc. However, these algorithms have a drawback: they cannot necessarily find the optimal solution, but can only converge to (approximately approach) the optimal solution, obtaining a suboptimal solution. This is because they are essentially random algorithms, and most of them use a similar idea of \"accepting or rejecting with a certain probability\" to filter solutions. The implementation ideas of each algorithm are different, but they also learn from each other to some extent. Some are related to random factors, some to initial states, some to random functions, and some to selection strategies."

#: ../../source/getting_started/tsp.rst:50
msgid "综合上述分析，TSP问题的求解大概是由以下两步构成："
msgstr "Based on the above analysis, the solution to the TSP problem generally consists of the following two steps:"

#: ../../source/getting_started/tsp.rst:52
msgid "**1.计算两两城市间的最短路径**：利用类似Diikstra、Flord、A星的算法求出最短路线。"
msgstr "**1. Calculate the shortest path between every pair of cities**: Use algorithms like Dijkstra, Floyd, or A* to find the shortest routes."

#: ../../source/getting_started/tsp.rst:54
msgid ""
"**2.计算最短巡回路径**：利用类似遗传算法、蚁群算法的搜索算法求巡回拜访的次序。 "
"关于1中需要说明一点，就是现实生活中我们的地图往往不是一个完全图，而是一个非完全图，甚至有些节点仅仅是道路的分岔口，而不是城市节点。完全图和非完全图的区别如下所示。"
msgstr ""
"**2. Calculate the shortest tour path**: Use search algorithms like genetic algorithms or ant colony algorithms to find the order of visiting cities. One point to note about step 1 is that in real life, our maps are often not complete graphs, but incomplete graphs. Some nodes are just road intersections, not city nodes. The difference between complete graphs and incomplete graphs is as follows."

#: ../../source/getting_started/tsp.rst:58
msgid "完全图和非完全图"
msgstr "Complete Graph and Incomplete Graph"

#: ../../source/getting_started/tsp.rst:60
msgid "完全图：两两城市间都有直达的路线，这条路线不需要经过中间其他节点；"
msgstr "Complete graph: There is a direct route between every pair of cities, and this route does not need to pass through other intermediate nodes;"

#: ../../source/getting_started/tsp.rst:64
msgid "非完全图：偶尔有两个城市间的路线需要经过其他中间节点。"
msgstr "Incomplete graph: Occasionally, the route between two cities needs to pass through other intermediate nodes."

#: ../../source/getting_started/tsp.rst:69
msgid "应用量子计算求解旅行商问题"
msgstr "Using Quantum Computing to Solve the Traveling Salesman Problem"

#: ../../source/getting_started/tsp.rst:72
msgid "1. 变量定义"
msgstr "1. Variable Definition"

#: ../../source/getting_started/tsp.rst:74
msgid ""
"给定一张有权重的连接图\\ :math:`G(V,E)`\\ ， \\ :math:`V`\\是节点的集合， \\ :math:`E`\\ "
"是边的集合。"
msgstr ""
"Given a weighted connected graph \\ :math:`G(V,E)`\\, \\ :math:`V`\\ is the set of nodes, and \\ :math:`E`\\ is the set of edges."

#: ../../source/getting_started/tsp.rst:75
msgid "我们使用距离矩阵来表示\\ :math:`G`\\ ，当两点间不存在边时，其权重值为\\ :math:`0`\\ 。"
msgstr "We use a distance matrix to represent \\ :math:`G`\\. When there is no edge between two points, its weight value is \\ :math:`0`\\."

#: ../../source/getting_started/tsp.rst:76
msgid "令\\ :math:`N=|V|`\\，\\ :math:`N`\\表示节点的数量。"
msgstr "Let \\ :math:`N=|V|`\\, where \\ :math:`N`\\ represents the number of nodes."

#: ../../source/getting_started/tsp.rst:77
#, python-brace-format
msgid ""
"令\\ :math:`x_{u,j}=1`\\ 代表点\\ :math:`u`\\ 在第\\ :math:`j`\\ 个点被访问，否则\\ "
":math:`x_{u,j}=0`\\ 。"
msgstr ""
"Let \\ :math:`x_{u,j}=1`\\ represent that point \\ :math:`u`\\ is visited at the \\ :math:`j`\\-th position, otherwise \\ :math:`x_{u,j}=0`\\."

#: ../../source/getting_started/tsp.rst:78
msgid "其中\\ :math:`v \\in 0...N-1`, :math:`j \\in 0...N-1`\\ 。"
msgstr "Where \\ :math:`v \\in 0...N-1`, :math:`j \\in 0...N-1`\\."

#: ../../source/getting_started/tsp.rst:81
msgid "2. 约束条件处理"
msgstr "2. Constraint Handling"

#: ../../source/getting_started/tsp.rst:83
msgid "首先，我们需要对于每一个\\ :math:`u`\\ ，只对应一个顺序\\ :math:`j`\\ ，则有："
msgstr "First, for each \\ :math:`u`\\, it corresponds to only one order \\ :math:`j`\\, so we have:"

#: ../../source/getting_started/tsp.rst:85
#, python-brace-format
msgid ""
"\\sum_{j=0}^{N-1}x_{u,j}=1, \\quad u \\in 0...N-1\n"
"\n"
msgstr ""
"\\sum_{j=0}^{N-1}x_{u,j}=1, \\quad u \\in 0...N-1\n"
"\n"

#: ../../source/getting_started/tsp.rst:87
msgid "其次，我们需要对于每一个顺序\\ :math:`j`\\ ，只对应一个点\\ :math:`u`\\ ，则有："
msgstr "Second, for each order \\ :math:`j`\\, it corresponds to only one point \\ :math:`u`\\, so we have:"

#: ../../source/getting_started/tsp.rst:89
#, python-brace-format
msgid ""
"\\sum_{u=0}^{N-1}x_{u,j}=1, \\quad j \\in 0...N-1\n"
"\n"
msgstr ""
"\\sum_{u=0}^{N-1}x_{u,j}=1, \\quad j \\in 0...N-1\n"
"\n"

#: ../../source/getting_started/tsp.rst:91
msgid "将以上两个约束写成QUBO形式，有："
msgstr "Writing the above two constraints in QUBO form, we have:"

#: ../../source/getting_started/tsp.rst:93
#, python-brace-format
msgid ""
"A \\sum_{u=0}^{N-1} (\\sum_{j=0}^{N-1}x_{u,j}-1)^2 + A \\sum_{j=0}^{N-1} "
"(\\sum_{u=0}^{N-1}x_{u,j}-1)^2\n"
"\n"
msgstr ""
"A \\sum_{u=0}^{N-1} (\\sum_{j=0}^{N-1}x_{u,j}-1)^2 + A \\sum_{j=0}^{N-1} "
"(\\sum_{u=0}^{N-1}x_{u,j}-1)^2\n"
"\n"

#: ../../source/getting_started/tsp.rst:95
msgid ""
"对于\\ :math:`(u,v)\\notin E`\\ ，我们希望\\ :math:`u`\\ 、\\ :math:`v`\\ "
"不连续出现在位置\\ :math:`j`\\ 、\\ :math:`j+1`\\ 上，则有："
msgstr ""
"For \\ :math:`(u,v)\\notin E`\\, we hope that \\ :math:`u`\\ and \\ :math:`v`\\ do not appear consecutively in positions \\ :math:`j`\\ and \\ :math:`j+1`\\, so we have:"

#: ../../source/getting_started/tsp.rst:97
#, python-brace-format
msgid ""
"A \\sum_{(u,v)\\notin E}(\\sum_{j=0}^{N-2}x_{u,j}x_{v,j+1} + "
"x_{u,N-1}x_{v,0})\n"
"\n"
msgstr ""
"A \\sum_{(u,v)\\notin E}(\\sum_{j=0}^{N-2}x_{u,j}x_{v,j+1} + "
"x_{u,N-1}x_{v,0})\n"
"\n"

#: ../../source/getting_started/tsp.rst:100
msgid "3. QUBO模型构建"
msgstr "3. QUBO Model Construction"

#: ../../source/getting_started/tsp.rst:102
msgid "如此，由以上的QUBO，我们可以构建一个遍历所有的点的路径的模型（又称哈密尔顿环）："
msgstr "Thus, from the above QUBO, we can construct a model for a path that traverses all points (also known as a Hamiltonian cycle):"

#: ../../source/getting_started/tsp.rst:104
#, python-brace-format
msgid ""
"H_A = A \\sum_{u=0}^{N-1} (\\sum_{j=0}^{N-1}x_{u,j}-1)^2 + A "
"\\sum_{j=0}^{N-1} (\\sum_{u=0}^{N-1}x_{u,j}-1)^2 + A \\sum_{(u,v)\\notin "
"E}(\\sum_{j=0}^{N-2}x_{u,j}x_{v,j+1} + x_{u,N-1}x_{v,0})\n"
"\n"
msgstr ""
"H_A = A \\sum_{u=0}^{N-1} (\\sum_{j=0}^{N-1}x_{u,j}-1)^2 + A "
"\\sum_{j=0}^{N-1} (\\sum_{u=0}^{N-1}x_{u,j}-1)^2 + A \\sum_{(u,v)\\notin "
"E}(\\sum_{j=0}^{N-2}x_{u,j}x_{v,j+1} + x_{u,N-1}x_{v,0})\n"
"\n"

#: ../../source/getting_started/tsp.rst:106
#, python-brace-format
msgid ""
"然而对于旅行商问题，在此基础上，我们想要获得上述路径中最短的一个。令\\ :math:`w_{u,v}`\\ 为边\\ "
":math:`(u,v)`\\ 的权重，则有："
msgstr ""
"However, for the Traveling Salesman Problem, on this basis, we want to obtain the shortest one among the above paths. Let \\ :math:`w_{u,v}`\\ be the weight of edge \\ :math:`(u,v)`\\, then we have:"

#: ../../source/getting_started/tsp.rst:108
#, python-brace-format
msgid ""
"H_B = B \\sum_{(u,v)\\in E}w_{u,v}(\\sum_{j=0}^{N-2}x_{u,j}x_{v,j+1} + "
"x_{u,N-1}x_{v,0})\n"
"\n"
msgstr ""
"H_B = B \\sum_{(u,v)\\in E}w_{u,v}(\\sum_{j=0}^{N-2}x_{u,j}x_{v,j+1} + "
"x_{u,N-1}x_{v,0})\n"
"\n"

#: ../../source/getting_started/tsp.rst:110
msgid "将两个QUBO表达式相加，即可得到最终的优化模型："
msgstr "Adding the two QUBO expressions together, we get the final optimization model:"

#: ../../source/getting_started/tsp.rst:112
msgid ""
"H = H_A + H_B\n"
"\n"
msgstr ""
"H = H_A + H_B\n"
"\n"

#: ../../source/getting_started/tsp.rst:114
msgid "优化目标是求H的最小值"
msgstr "The optimization goal is to find the minimum value of H"

#: ../../source/getting_started/tsp.rst:116
msgid "实现用Solver直接对QuboModel进行求解"
msgstr "Implement direct solving of QuboModel using Solver"

#: ../../source/getting_started/tsp.rst:118
msgid ""
"注：Solver求解器是针对QUBOModel的求解工具，它用QUBO Model生成Ising矩阵，使用提供的Optimizer来求解。 "
"本例子使用一个具有基本功能的Solver来求解。"
msgstr ""
"Note: The Solver is a solving tool for QUBOModel. It generates an Ising matrix from the QUBO Model and uses the provided Optimizer to solve it. This example uses a Solver with basic functions for solving."

#: ../../source/getting_started/tsp.rst:124
msgid "加载依赖包"
msgstr "Loading Dependencies"

#: ../../source/getting_started/tsp.rst:133
#, python-brace-format
msgid "加载图数据， 并做预处理。 下面的代码中定义了x变量就是模型中的决策变量\\ :math:`x_{u,j}=1`\\。"
msgstr ""
"Load graph data and perform preprocessing. The x variable defined in the following code is the decision variable \\ :math:`x_{u,j}=1`\\ in the model."

#: ../../source/getting_started/tsp.rst:154
msgid ""
"使用add_constraint加载约束项，set_objective构建目标函数。其中add_constraint需要输入penalty参数。 "
"具体数值根据问题会有所不同。"
msgstr ""
"Use add_constraint to load constraints and set_objective to build the objective function. The add_constraint requires a penalty parameter. The specific value will vary depending on the problem."

#: ../../source/getting_started/tsp.rst:178
msgid "5. 使用经典求解器进行计算"
msgstr "5. Using Classical Solver for Calculation"

#: ../../source/getting_started/tsp.rst:180
msgid "该问题有三个硬约束（点约束、位置约束和边约束）。硬约束的取值必须严格为\\ :math:`0`\\ 才能形成合法的路径。"
msgstr "This problem has three hard constraints (point constraints, position constraints, and edge constraints). The value of hard constraints must be strictly \\ :math:`0`\\ to form a valid path."

#: ../../source/getting_started/tsp.rst:194
msgid "6.计算最终路径"
msgstr "6. Calculating the Final Path"

#: ../../source/getting_started/tsp.rst:196
msgid "进一步给出求得的路径。我们使用get_val模块进行转化。"
msgstr "Further present the obtained path. We use the get_val module for conversion."

#: ../../source/getting_started/tsp.rst:217
msgid ""
"以上我们获得了路径的合法性和长度，下面我们恢复\\ :math:`x`\\ 变量的值并获取路径。 "
"通过get_array_val，拿到前面定义的x向量对应的值，然后通过np.array(np.nonzero(x_val.T))[1]拿到不等于0的位置索引值。就是我们要的最终结果。"
msgstr ""
"Above, we obtained the validity and length of the path. Now, we restore the value of the \\ :math:`x`\\ variable and obtain the path. Through get_array_val, we get the value corresponding to the previously defined x vector, and then use np.array(np.nonzero(x_val.T))[1] to get the position index values that are not equal to 0. This is the final result we want."

#: ../../source/getting_started/tsp.rst:240
msgid "这表示路径上1号位置选择0号节点，2号位置选择1号节点，3号位置选择2号节点等等。"
msgstr "This indicates that position 1 on the path selects node 0, position 2 selects node 1, position 3 selects node 2, and so on."

#: ../../source/getting_started/tsp.rst:243
msgid "7. 使用光量子计算机进行计算"
msgstr "7. Using Optical Quantum Computer for Calculation"

#: ../../source/getting_started/tsp.rst:245
msgid "使用真机计算的话，需要使用如下代码生成csv文件上传给云平台"
msgstr "For calculation using the physical machine, you need to use the following code to generate a csv file and upload it to the cloud platform"

#: ../../source/getting_started/tsp.rst:252
msgid "使用玻色量子云平台来调用相干伊辛机来求解TSP问题，得到的结果如下图所示。该结果的最短路径值经过验证与上述方法相同，耗时约为1.66ms。"
msgstr "Using the QBoson Quantum Cloud Platform to call the Coherent Ising Machine to solve the TSP problem, the obtained results are shown in the figure below. The shortest path value of this result has been verified to be the same as the above method, with a time consumption of approximately 1.66ms."

#: ../../source/getting_started/tsp.rst:256
msgid "结果1是最优解，按照前面变量定义，每5个一组代表图上一个节点，每组5个变量表示5个位置，值为1表示第一个节点在路径的对应位置通过。"
msgstr "Result 1 is the optimal solution. According to the variable definition above, every 5 variables form a group representing a node on the graph. Each group of 5 variables represents 5 positions, and a value of 1 indicates that the first node passes through the corresponding position on the path."